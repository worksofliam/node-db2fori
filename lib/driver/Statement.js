const {DatabaseRequestAttributes} = require('../data/DatabaseRequestAttributes');
const Connection = require('./Connection');

const StatementResult = require('../data/StatementResult');
const StatementType = require('../data/StatementType');

const {SQL_MESSAGES} = require('../data/Errors');

module.exports = class Statement {
  /**
   * @param {Connection} connection 
   * @param {string} statementName 
   * @param {string} cursorName 
   * @param {number} rpbID 
   */
  constructor(connection, statementName, cursorName, rpbID) {
    this.connection = connection;
    this.statementName = statementName;
    this.cursorName = cursorName;
    this.rpbID = rpbID;

    /** @type {DatabaseRequestAttributes} */
    this.statementAttributes = undefined;
    /** @type {DatabaseRequestAttributes} */
    this.attributes = undefined;

    /** @type {string} */
    this.catalog = undefined;

    /** @type {string} */
    this.generatedKey = undefined;

    this.currentResultSet = undefined;

    this.fetchSize = 0;
  }

  /**
   * This needs to be called right after the Statement has been constructed.
   */
  async initialRequest() {
    if (this.rpbID !== 0) {
      var dbRequestAttributes = new DatabaseRequestAttributes();
      dbRequestAttributes.cursorName = this.cursorName;
      dbRequestAttributes.prepareStatementName = this.statementName;
      await this.connection.createRequestParameterBlock(dbRequestAttributes, this.rpbID);

      this.attributes = dbRequestAttributes;
      this.statementAttributes = dbRequestAttributes.copy();
    }
  }

  /**
   * 
   * @param {string} sql SQL statement
   * @param {*} autoGeneratedKeys See data/StatementResult.js
   * @returns {boolean} Returns true if the execution was successful
   */
  async execute(sql, autoGeneratedKeys = StatementResult.NO_GENERATED_KEYS) {
    if (this.currentResultSet !== undefined)
    {
      //TODO: later
      //this.currentResultSet.close();
      this.currentResultSet = null;
    }

    const statementType = Statement.getStatementType(sql);

    if (statementType === StatementType.SELECT) {
      this.currentResultSet = await this.executeQuery(sql);
      return true;
    }
  }

  /**
   * @param {string} sql SQL statement
   */
  async executeQuery(sql) {
    const dbConnection = this.connection.connection;

    if (this.catalog === undefined) {
      this.catalog = this.connection.getCatalog();
    }

    //conn.setSQLCommunicationsAreaCallback(this);
    const pea = new DatabaseRequestAttributes();
    pea.extendedSQLStatementText(sql);

    const statementType = Statement.getStatementType(sql);
    switch (statementType) {
      case StatementType.SELECT:
        pea.openAttributes = 0x80;
        pea.extendedColumnDescriptorOption = 0xF1;
        break;

      case StatementType.CALL:
        //Doesn't do anything??
        break;

      default:
        throw new Error("executeQuery - not a query");
    }

    pea.sqlStatementType = statementType;

    try {
      dbConnection.currentRPB = this.rpbID;
      this.generatedKey = undefined;

    } catch (e) {}
  }

  /**
   * @param {string} sql SQL query
   * @return {number} StatementType. See data/StatementType
   */
  static getStatementType(sql) {
    var queryType = StatementType.UNKNOWN;
    sql = sql.trim().toUpperCase();

    if (sql.length > (2097152 / 2)) {
      throw new Error(SQL_MESSAGES.EXC_SQL_STATEMENT_TOO_LONG);
    } else {
      const queryStart = sql.split(' ')[0];

      switch (queryStart) {
        case 'SELECT':
        case 'VALUES':
          queryType = StatementType.SELECT;
          break;

        case 'INSERT':
        case 'UPDATE':
        case 'DELETE':
          queryType = StatementType.INSERT_UPDATE_DELETE;
          break;

        case 'CALL':
          queryType = StatementType.CALL;
          break;

        case 'COMMIT':
          queryType = StatementType.COMMIT;
          break;

        case 'ROLLBACK':
          queryType = StatementType.ROLLBACK;
          break;

        case 'CONNECT':
        case 'SET':
        case 'RELEASE':
        case 'DISCONNECT':
          queryType = StatementType.ROLLBACK;
          break;

        case 'BLOCKED':
          queryType = StatementType.BLOCKED_INSERT;
          break;
          
      }
    }

    return queryType;
  }
}